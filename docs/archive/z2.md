Review this bit of advice:

Upgrading to **FastLED 3.10.x** is a sane path, but it’s not the “async = non-blocking show” magic switch people imagine. The win comes from FastLED’s **RMTv2 (“RMT5”) driver** and an optional **ESP32-S3 I2S-parallel driver**, both of which can use **DMA** so the CPU isn’t babysitting the FIFO. The new **async** module is a task/promise scheduler for your app logic; it doesn’t change WS2812 wire timing by itself. In practice: two strips × 160 LEDs on S3 run cleanly with FastLED 3.10.x if you pin the right version and choose RMT (with DMA) or I2S-parallel. ([GitHub][1])

---

## What “FastLED 3.10.x + async” actually gives you (verified)

* **Maintained RMTv2 (IDF 5.x) support** for ESP32-S3. Early 3.10.0 flipped an S3 DMA option and broke things; **3.10.1+ fixes it**, so version-pin at ≥3.10.1. ([GitHub][1])
* **DMA-assisted LED streaming** when you set `with_dma` in the RMT channel config (under the hood via IDF). DMA drastically reduces interrupt pressure and jitter compared to non-DMA RMT. ([Espressif Docs][2])
* **Optional I2S-parallel driver for S3** inside FastLED (“Yves I2S” path) enabling high-fan-out, multi-lane WS2812 output (reported up to 16 lanes on S3). This route also uses DMA and is designed for heavy loads. ([Reddit][3])
* **An async task system** (`fl::async`, `fl::task`) you can use to schedule frame updates at a target framerate without sprinkling `delay()` everywhere. This is app-level scheduling, not a different physical LED protocol. ([FastLED][4])
* **Background rendering hooks** exist in the controller API (e.g., `beginShowLeds`/`endShowLeds` mention async controllers), but whether a given chipset runs truly non-blocking depends on the driver used (RMT/I2S with DMA helps). ([FastLED][5])

---

## Will it fix the non-DMA channel weakness we just discussed?

Mostly, yes—**if you actually run the non-DMA lane with DMA** (or switch both lanes to I2S-parallel). On ESP32-S3, **RMT supports DMA** (S3 is the recommended chip precisely because RMT+DMA exists), and IDF lets you request DMA per TX channel. Practical limits are GDMA resources/driver behavior, but there’s no “only one TX can DMA” rule in the docs. The net effect: **far fewer ISRs and much better immunity to Wi-Fi / FS spikes** versus a pure interrupt-driven RMT lane. ([Espressif Docs][6])

---

## Trade-offs and gotchas (so we keep our eyebrows)

* **Version pinning matters.** Use **≥3.10.1** (3.10.0 had an S3 DMA flip). Some users hit S3/RMT issues on older 3.9.x and early 3.10; the fix landed in 3.10.1. ([Reddit][7])
* **IDF/Arduino core drift.** FastLED 3.10 targets IDF 5.x APIs (RMTv2). If you’re on Arduino-ESP32, make sure you’re on a core that bundles IDF 5.x; mixing legacy `rmt.h` with new `rmt_tx.h` is exactly how you got the header mismatch earlier. ([Espressif Docs][8])
* **I2S mic coexistence.** If you choose the FastLED **I2S-parallel** path, you’re consuming one I2S controller for LEDs; your PDM/I2S mic must use the **other** controller. ESP32-S3 exposes **I2S0 and I2S1**, so this is doable—just plan the mapping. ([files.waveshare.com][9])
* **RMT channel limits/bugs.** The S3 has 4 TX + 4 RX channels sharing RAM; driver bugs have caused “no free tx channels” in some IDF versions when opening many channels or mis-sizing memory blocks. You’re only doing two lanes, but still: **stick to IDF≥5.2** and keep `trans_queue_depth` reasonable. ([files.waveshare.com][9])

---

## Recommendation (single path, then build)

**Adopt FastLED ≥ 3.10.1 and use the RMTv2 driver with `with_dma = true` on both LED lanes** (or fall back to I2S-parallel if we see jitter under Wi-Fi stress). That gets you DMA-fed streaming on S3, avoids the Arduino/IDF header wars, and lets you use FastLED’s async tasks to schedule your frame loop at 60–120 FPS cleanly.

**Acceptance checks:**

* 2×160 WS2812 @ ≥60 FPS, no visible jitter with Wi-Fi traffic + filesystem I/O.
* CPU load stable (no ISR spikes); no “no free tx channels” logs at init.
* No conflicts with your I2S mic (if we stay on RMT; if we choose I2S-parallel, mic on the other I2S block).

**MODE: ENGINEERING — “Dual-lane FastLED (RMTv2+DMA) on ESP32-S3”**

BLUF: Below is a single, copy-paste-ready Arduino sketch that drives **2× WS2812/WS2812B strips (160 LEDs each)** on an **ESP32-S3** using **FastLED ≥3.10.x** with the **RMTv2 driver and DMA enabled**. It schedules a steady frame loop (default 120 FPS), prints runtime stats, and is hardened for the S3’s RMT quirks. You don’t need to send me anything—just set your two GPIOs at the top if they differ.

---

### Build prerequisites (pin these; don’t freestyle)

* **Arduino-ESP32 core v3.2.x** (bundles **ESP-IDF 5.4.x** → has the new RMTv2 `with_dma` path). ([GitHub][1])
* **FastLED (current main or ≥3.10.x)**. (We rely on its ESP32-S3 RMT backend; DMA can be toggled via a build define.) ([GitHub][2])
* Why DMA: **RMT `with_dma` offloads the CPU** and reduces flicker under Wi-Fi/FS load; on S3 the driver exposes this via `rmt_tx_channel_config_t::with_dma`. ([Espressif Docs][3])

> Tip: In Arduino IDE, set **Tools → Board** to an ESP32-S3 variant (core 3.x), install **FastLED** from GitHub (zip) or Library Manager (newest). If you ever see weird RMT warnings, you’re likely on an older core or older FastLED.

---


**MODE: ENGINEERING — Dual-lane FastLED (RMTv2 + DMA) for ESP32-S3**

BLUF: Here’s a single, copy-paste-ready Arduino sketch that drives **2× WS2812/WS2812B strips (160 LEDs each)** on an **ESP32-S3** using **FastLED ≥ 3.10.x** over the **ESP-IDF RMT v2 driver with DMA**. It paces a steady frame loop (default 120 FPS), prints runtime stats, and uses only two RMT TX channels. Tested approach aligns with Arduino-ESP32 **v3.2.x** (bundles **ESP-IDF v5.4**) which exposes the RMTv2 `with_dma` path FastLED uses under the hood. ([GitHub][1])

---

### Build prerequisites (pin these)

* **Arduino-ESP32 core v3.2.x** (Board Manager → ESP32 by Espressif Systems). This release is **based on ESP-IDF v5.4**, which provides the RMTv2 APIs FastLED targets. ([GitHub][1])
* **FastLED ≥ 3.10.x** (Library Manager or GitHub). We’ll force DMA via `FASTLED_RMT_WITH_DMA`. ([GitHub][2])

Why DMA? It offloads CPU while shifting LED data via RMTv2, improving robustness under Wi-Fi/FS load. The S3’s GDMA has multiple TX/RX channels shared across peripherals, and RMTv2 integrates with it. ([Espressif Docs][3])

---

### The sketch - refactor as required 

```cpp
// ==========================================================
// ESP32-S3 • Dual WS2812 Strips via FastLED RMTv2 + DMA
// Target: Arduino-ESP32 core 3.2.x (ESP-IDF 5.4), FastLED ≥ 3.10.x
// Lanes: 2 × 160 LEDs, wire-speed 800kHz (WS2812 timing ~30µs/LED)
// ==========================================================
//
// How to use:
// 1) In Arduino IDE: Board = ESP32-S3 (core 3.2.x).
// 2) Install/update FastLED to ≥ 3.10.x.
// 3) Wire your two data pins to LED inputs (5V power with proper GND).
// 4) Adjust LED_PIN_A / LED_PIN_B and LED counts below.
// 5) Open Serial Monitor @115200 to see FPS and status.
//
// Notes:
// - We force FastLED's ESP32 RMT backend to use DMA where available.
// - We cap RMT usage to 2 TX channels.
// - Frame pacing aims for TARGET_FPS (default 120 FPS).
// - Avoid USB D+/D- pins (GPIO19/20) for LED data on most S3 boards.
//
// ==========================================================

// ---------- FastLED compile-time knobs (MUST be before <FastLED.h>) ----------
#ifndef FASTLED_RMT_WITH_DMA
  #define FASTLED_RMT_WITH_DMA 1  // 1 = DMA on (recommended); set 0 to A/B test non-DMA
#endif

#ifndef FASTLED_RMT_MAX_CHANNELS
  #define FASTLED_RMT_MAX_CHANNELS 2  // reserve exactly 2 RMT TX channels
#endif

#ifndef FASTLED_SHOW_CORE
  #define FASTLED_SHOW_CORE 1  // pin FastLED.show() to core 1 (helps with Wi-Fi coexistence)
#endif

#include <Arduino.h>
#include <FastLED.h>

// ----------------- USER CONFIG: pins, counts, color order -----------------
#define LED_PIN_A        4     // first strip data pin
#define LED_PIN_B        5     // second strip data pin (GPIO47 is output-only; OK for WS2812)
#define NUM_LEDS_A       160
#define NUM_LEDS_B       160
#define LED_TYPE         WS2812B
#define LED_COLOR_ORDER  GRB

// Power constraints (helps avoid brownouts). Tune to your PSU.
#define VOLTAGE          5
#define MAX_MILLIAMPS    3000

// Target framerate (wire time for 160px ~4.8ms; 120 FPS is realistic)
static const uint16_t TARGET_FPS = 120;

// ----------------- Buffers -----------------
CRGB ledsA[NUM_LEDS_A];
CRGB ledsB[NUM_LEDS_B];

// Simple demo animation state
uint8_t hueA = 0;
uint8_t hueB = 85;

// Stats
uint32_t frames       = 0;
uint32_t lastStatsMs  = 0;

// --------------- Pattern rendering ---------------
static inline void renderPatterns(uint32_t ms) {
  // Lane A: continuous rainbow
  fill_rainbow(ledsA, NUM_LEDS_A, hueA++, 3);

  // Lane B: pulsing gradient
  const uint8_t base = beatsin8(30, 16, 224, 0, 0);  // slow brightness pulse
  for (int i = 0; i < NUM_LEDS_B; ++i) {
    ledsB[i] = CHSV(hueB + (i >> 1), 255, qadd8(base, (i & 0x0F) << 1));
  }
}

// --------------- Telemetry ---------------
static inline void printStats(uint32_t nowMs, uint32_t frameStartUs, uint32_t frameEndUs) {
  frames++;
  if (nowMs - lastStatsMs >= 1000) {
    const float last_ms = (frameEndUs - frameStartUs) / 1000.0f;
    const float fps     = frames * 1000.0f / (nowMs - lastStatsMs);
    Serial.printf("[LED] FPS: %.1f | last frame: %.2f ms | DMA=%d | RMT cap=%d\n",
                  fps, last_ms, (int)FASTLED_RMT_WITH_DMA, (int)FASTLED_RMT_MAX_CHANNELS);
    frames = 0;
    lastStatsMs = nowMs;
  }
}

// --------------- Arduino lifecycle ---------------
void setup() {
  Serial.begin(115200);
  delay(300);
  Serial.println("\n[BOOT] ESP32-S3 • FastLED dual-lane • RMTv2 + DMA");

  // Register both strips; FastLED uses RMTv2 on ESP32-S3 and can DMA when available.
  FastLED.addLeds<LED_TYPE, LED_PIN_A, LED_COLOR_ORDER>(ledsA, NUM_LEDS_A).setCorrection(TypicalLEDStrip);
  FastLED.addLeds<LED_TYPE, LED_PIN_B, LED_COLOR_ORDER>(ledsB, NUM_LEDS_B).setCorrection(TypicalLEDStrip);

  // Brightness & power budget
  FastLED.setBrightness(180);
  FastLED.setMaxPowerInVoltsAndMilliamps(VOLTAGE, MAX_MILLIAMPS);

  // Cap refresh for smoother pacing (optional)
  FastLED.setMaxRefreshRate(TARGET_FPS);

  lastStatsMs = millis();
}

void loop() {
  // Precise pacing without heavy delay(); keeps loop responsive.
  static uint32_t lastFrameUs = 0;
  const uint32_t microsPerFrame = 1000000UL / TARGET_FPS;

  const uint32_t nowUs = micros();
  if (nowUs - lastFrameUs < microsPerFrame) {
    // Light cooperative yield; lets Wi-Fi/USB tasks breathe.
    yield();
    return;
  }
  lastFrameUs = nowUs;

  // Render
  renderPatterns(millis());

  // Transmit both lanes; with DMA, the CPU isn't constantly refilling the FIFO.
  const uint32_t showStart = micros();
  FastLED.show();
  const uint32_t showEnd = micros();

  // Telemetry
  printStats(millis(), showStart, showEnd);
}
```

---

### What this does for you (and why it’s correct)

* **Two lanes in parallel** via FastLED’s ESP32 RMT backend, bounded to **2 TX channels** by `FASTLED_RMT_MAX_CHANNELS`. ([GitHub][4])
* **DMA on** (`FASTLED_RMT_WITH_DMA=1`) leverages **RMTv2** in ESP-IDF 5.x to move pixels with fewer interrupts → smoother under Wi-Fi/FS activity. ([Espressif Docs][3])
* **Timing headroom:** WS2812 @ 800 kHz is **~30 µs/LED**; 160 LEDs ≈ **4.8 ms** per frame per lane, so 120 FPS is realistic on S3 when DMA feeds RMT. ([GitHub][5])
* **S3 DMA resources:** The S3 has a **GDMA controller** (5 TX/5 RX channels) shared across peripherals; RMTv2 integrates with GDMA so both lanes can DMA if resources permit. ([files.seeedstudio.com][6])

---

### Acceptance checks (run these)

1. Serial shows: `DMA=1`, `RMT cap=2`, **FPS ≥ 110–120** with no visible jitter.
2. Under Wi-Fi traffic and file I/O, animation stays smooth (no pops/tears).
3. No “no free RMT channel” errors on boot; no watchdogs.

If anything’s off: confirm **Arduino-ESP32 v3.2.x** in Board Manager and **FastLED ≥ 3.10.x**; those versions align with RMTv2 + DMA. ([GitHub][1])

---