QUICK REFERENCE - K1.node1 Audio Pipeline Architecture
========================================================

FILE LOCATIONS & LINE NUMBERS
=============================

1. ENTRY POINT - Audio Capture Starts
   File: firmware/src/main.cpp
   - audio_task() function: lines 240-449
   - Runs on Core 0 @ ~100 Hz
   - Call chain: acquire → calculate → tempo → sync → emit beats

2. I2S MICROPHONE INITIALIZATION & DATA
   File: firmware/src/audio/microphone.h (lines 1-91)
   File: firmware/src/audio/microphone.cpp (lines 1-252)
   - Hardware: SPH0645, GPIO 14/12/13 (BCLK/LRCLK/DIN)
   - Sample rate: 16 kHz, 128-sample chunks (8ms)
   - init_i2s_microphone(): Lines 34-73 (IDF5) or 75-109 (IDF4)
   - acquire_sample_chunk(): Lines 113-252
   - Timeout protection (Phase 0): Lines 120-197
   - Audio buffer: sample_history[4096] (256ms @ 16kHz)

3. AUDIO BUFFER MANAGEMENT
   Files: firmware/src/audio/goertzel.h (148-149)
          firmware/src/audio/goertzel.cpp (all)
   - Global buffers defined: lines 135-183
   - sample_history[4096]: Ring buffer input
   - spectrogram[64]: Auto-ranged frequency spectrum
   - spectrogram_smooth[64]: 8-frame smoothed
   - spectrogram_absolute[64]: Pre-normalized (absolute loudness)
   - chromagram[12]: 12 pitch classes
   - tempi[64]: Tempo hypothesis state
   - tempi_smooth[64]: Smoothed tempi

4. FFT COMPUTATION (Goertzel Algorithm)
   File: firmware/src/audio/goertzel.cpp
   - calculate_magnitudes(): Lines 403-591
   - Goertzel on 64 frequency bins (musical scale)
   - Auto-ranging: max_val_smooth smoothing (lines 462-474)
   - VU calculation: Lines 487-514 with frequency weighting
   - Spectrogram averaging: 6-sample moving average (430-440)
   - Copy to audio_back: Lines 560-586
   - get_chromagram(): Lines 600-620

5. GOERTZEL TEMPO DETECTION (All 64 Bins)
   File: firmware/src/audio/tempo.h (1-83)
   File: firmware/src/audio/tempo.cpp (1-435)
   - tempo struct: goertzel.h lines 74-89
   - Tempo range: 32-192 BPM (64 bins, NUM_TEMPI)
   - Novelty detection: update_novelty() lines 345-374 (spectral flux)
   - Tempo magnitude: calculate_tempi_magnitudes() (Goertzel on novelty)
   - update_tempo(): Lines 276-297 (interlaced, 2 bins/frame)
   - Phase tracking: update_tempi_phase() lines 402-430
   - Beat phase sync: sync_beat_phase() lines 376-400

6. AUDIO SNAPSHOT SYNCHRONIZATION (Double-Buffering)
   File: firmware/src/audio/goertzel.h
   - AudioDataSnapshot struct: Lines 91-129 (1,300+ bytes)
   - audio_front (Core 1 reads): Line 185
   - audio_back (Core 0 writes): Line 186
   File: firmware/src/audio/goertzel.cpp
   - commit_audio_data(): Lines 184-222 (write with sequence counter)
   - get_audio_snapshot(): Lines 127-168 (read with retry loop)
   - finish_audio_frame(): Lines 627-634 (calls commit_audio_data)
   - Sequence counter: even=valid, odd=writing

7. PATTERN ACCESS TO AUDIO DATA (Thread-Safe)
   File: firmware/src/pattern_audio_interface.h (1-637)
   File: firmware/src/pattern_audio_interface.cpp (1-99)
   - PATTERN_AUDIO_START() macro: Lines 79-89 (create snapshot)
   - AUDIO_SPECTRUM[i]: Lines 152 (auto-ranged, 0-1.0)
   - AUDIO_SPECTRUM_ABSOLUTE[i]: Line 154 (pre-normalized)
   - AUDIO_TEMPO_PHASE(bin): Line 453 (-π to +π per bin)
   - AUDIO_TEMPO_MAGNITUDE(bin): Line 421 (0.0-1.0 per bin)
   - Convenience bands: AUDIO_BASS(), AUDIO_MIDS(), AUDIO_TREBLE()
   - Query macros: AUDIO_IS_FRESH(), AUDIO_IS_STALE(), AUDIO_AGE_MS()

8. MUTEXES, LOCKS, THREAD SAFETY
   File: firmware/src/audio/goertzel.h
   - audio_front.sequence: atomic<uint32_t> (line 98)
   - audio_front.sequence_end: atomic<uint32_t> (line 128)
   - Memory barriers: __sync_synchronize() (see commit_audio_data)
   File: firmware/src/audio/microphone.cpp
   - waveform_locked: atomic<bool> (line 10)
   - waveform_sync_flag: atomic<bool> (line 11)
   File: firmware/src/main.cpp
   - audio_spinlock: portMUX_TYPE (line 336)
   - Protects tempo_magnitude[] & tempo_phase[] copy (lines 346-351)

9. LATENCY BREAKDOWN
   I2S read: 8ms (blocking)
   Goertzel: 15-25ms (64 bins, interlaced 2/frame)
   Tempo: 5-10ms (interlaced)
   Other: ~1-2ms (chromagram, novelty, phase, sync)
   ─────────────────────
   Total: 40-50ms one-way latency (mic to LED)

10. TIMING-CRITICAL SECTIONS
    File: firmware/src/main.cpp
    - audio_task loop: Lines 240-449
    - loop_gpu (render): Lines 556-626
    - Frame timing: ~50-100 Hz audio processing @ ~100+ FPS rendering
    - No hard real-time guarantees (FreeRTOS not hard-RT)

KEY CONSTANTS
=============
SAMPLE_RATE: 16000 Hz
CHUNK_SIZE: 128 samples = 8ms
NUM_FREQS: 64 frequency bins
NUM_TEMPI: 64 tempo hypotheses (32-192 BPM)
SAMPLE_HISTORY_LENGTH: 4096 samples = 256ms @ 16kHz
NOVELTY_HISTORY_LENGTH: 1024 samples @ 50 Hz = 20.48s history
REFERENCE_FPS: 100 Hz (phase update cadence)

SYNCHRONIZATION STRATEGY
========================
Lock-free double-buffering:
- Core 0 writes to audio_back, commits via memcpy + sequence counter
- Core 1 reads from audio_front with retry loop on torn read detection
- No mutexes on hot path (only spinlock for tempo array copy)
- Memory barriers ensure CPU cache coherency on ESP32-S3

CRITICAL DESIGN DECISIONS
=========================
1. Interlaced Goertzel: Only 2 bins calculated per frame (32 frames to do all 64)
   → Spreads CPU load, prevents stalls
2. Auto-ranging spectrum: Normalized to loudest bin (0.0-1.0)
   → Ensures visual response at any volume
3. Exponential phase tracking: sin(phase) for smooth beat animation
   → Enables beat-locked effects
4. Double-buffering snapshot: Pattern access never blocks
   → Render loop never waits for audio processing
5. Novelty-based tempo: Spectral flux on 20s history
   → More stable than raw RMS, handles music onset detection

KNOWN LIMITATIONS
=================
- 50ms+ latency audio → LED (I2S block + Goertzel CPU)
- No hard real-time guarantees (FreeRTOS preemption)
- Audio jitter: ±5-10ms typical
- Wifi/OTA updates cause temporary stalls
- 256ms audio history limits onset detection window

NEXT STEPS FOR DEEP DIVES
=========================
1. Measure actual I2S timing & buffer profiling
2. Profile Goertzel CPU cost per bin (microbenchmark)
3. Trace Core 0 ↔ Core 1 synchronization overhead
4. Analyze phase jitter in tempo detection (FFT vs beat grid)
5. Stress test: Max pattern complexity + audio load
