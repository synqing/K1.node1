// ============================================================================
// LAVA PATTERN CODE GENERATOR
// Converts lava_graph.json node graph to C++ pattern code
// Generated: 2025-11-10
// ============================================================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <cmath>

// ============================================================================
// CODE GENERATION TEMPLATES
// ============================================================================

const char* LAVA_GENERATED_HEADER = R"(
// ============================================================================
// GENERATED: Lava Pattern (from lava_graph.json)
// This code was generated by lava_codegen.cpp
// DO NOT EDIT MANUALLY - regenerate from graph instead
// ============================================================================

#pragma once

#include "pattern_registry.h"
#include "palettes.h"
#include <math.h>
#include <algorithm>

extern CRGBF leds[NUM_LEDS];

)";

const char* LAVA_GENERATED_FUNCTION = R"(
void draw_lava_generated(float time, const PatternParameters& params) {
    // Lava palette: Black → Deep Red → Bright Orange → White Hot
    const CRGBF palette_colors[] = {
        CRGBF(0.00f, 0.00f, 0.00f), CRGBF(0.07f, 0.00f, 0.00f), CRGBF(0.44f, 0.00f, 0.00f),
        CRGBF(0.56f, 0.01f, 0.00f), CRGBF(0.69f, 0.07f, 0.00f), CRGBF(0.84f, 0.17f, 0.01f),
        CRGBF(1.00f, 0.32f, 0.02f), CRGBF(1.00f, 0.45f, 0.02f), CRGBF(1.00f, 0.61f, 0.02f),
        CRGBF(1.00f, 0.80f, 0.02f), CRGBF(1.00f, 1.00f, 0.02f), CRGBF(1.00f, 1.00f, 0.28f),
        CRGBF(1.00f, 1.00f, 1.00f)
    };
    const int palette_size = 13;

    // ========== MAIN LED LOOP ==========
    for (int i = 0; i < NUM_LEDS; i++) {
        // CENTER-ORIGIN: Distance from center (0.0 at center → 1.0 at edges)
        float position = (fabsf((float)i - (NUM_LEDS / 2.0f)) / (NUM_LEDS / 2.0f));
        position = fmaxf(0.0f, fminf(1.0f, position));

        // Palette interpolation
        int palette_index = (int)(position * (palette_size - 1));
        float interpolation_factor = (position * (palette_size - 1)) - palette_index;

        // Clamp to valid range
        if (palette_index >= palette_size - 1) {
            leds[i] = palette_colors[palette_size - 1];
        } else {
            const CRGBF& color1 = palette_colors[palette_index];
            const CRGBF& color2 = palette_colors[palette_index + 1];

            leds[i].r = color1.r + (color2.r - color1.r) * interpolation_factor;
            leds[i].g = color1.g + (color2.g - color1.g) * interpolation_factor;
            leds[i].b = color1.b + (color2.b - color1.b) * interpolation_factor;
        }

        // Apply runtime parameters: brightness multiplier
        leds[i].r *= params.brightness;
        leds[i].g *= params.brightness;
        leds[i].b *= params.brightness;
    }

    // Apply uniform background overlay
    apply_background_overlay(params);
}
)";

// ============================================================================
// MAIN GENERATOR
// ============================================================================

int main(int argc, char** argv) {
    printf("%s\n", LAVA_GENERATED_HEADER);
    printf("%s\n", LAVA_GENERATED_FUNCTION);
    return 0;
}
