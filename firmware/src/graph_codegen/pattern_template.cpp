/**
 * K1.node1 Graph Pattern Template
 *
 * This file shows the structure of auto-generated pattern code.
 * Generated patterns follow this structure for consistency.
 *
 * Generated by: k1c compiler
 * Pattern name: <graph_name>
 * Nodes: <count> types
 *
 * DO NOT EDIT - auto-generated from <graph>.json
 */

#include "graph_runtime.h"
#include "../stateful_nodes.h"
#include "../parameters.h"
#include "../pattern_audio_interface.h"

namespace pattern_example {

// ============================================================================
// PATTERN CONSTANTS & CONFIGURATION
// ============================================================================

static constexpr int PATTERN_NUM_LEDS = 256;
static constexpr int FRAME_RATE = 30;  // Hz

// ============================================================================
// HELPER STRUCTURES & FUNCTIONS
// ============================================================================

// (Compiler emits per-node helper functions here)

// ============================================================================
// PATTERN RENDER FUNCTION (Entry point)
// ============================================================================

/**
 * Render one frame of the pattern
 *
 * Args:
 *   frame_count: Frame number since pattern start (uint32_t)
 *   audio: Current audio snapshot (VU + spectrum)
 *   params: Pattern parameters from UI
 *   state: Persistent state (stateful nodes)
 *   out: Output LEDs (clamped and written here)
 *
 * Execution order:
 *   1. Declare persistent & temporary buffers
 *   2. Compute all nodes in topological order
 *   3. Write final buffer to out.leds with RGB clamping
 *   4. Update stateful node state for next frame
 */
extern "C" void pattern_example_render(
    uint32_t /*frame_count*/,
    const AudioDataSnapshot& audio,
    const PatternParameters& /*params*/,
    PatternState& state,
    PatternOutput& out
) {
    // ========================================================================
    // DECLARE BUFFERS & SCALARS
    // ========================================================================

    // Persistent buffers (allocated once, reused every frame)
    // static CRGBF persistent_buf_0[PATTERN_NUM_LEDS];  // For BufferPersist nodes

    // Temporary buffers (pooled scratch, reused across frame)
    CRGBF temp_buf_0[PATTERN_NUM_LEDS];
    // CRGBF temp_buf_1[PATTERN_NUM_LEDS];

    // Scalar temporaries (for intermediate values)
    // float time_val;
    // float envelope_val;
    // float color_val;

    // ========================================================================
    // COMPUTE NODES IN TOPOLOGICAL ORDER
    // ========================================================================

    // Example node computations (generated per graph):
    // NOTE: Commented parameters cannot be used; uncomment in generated code

    // // Node: Time (pure, input)
    // time_val = frame_count / 30.0f;

    // // Node: AudioSnapshot (pure, input)
    // envelope_val = audio.envelope;

    // // Node: Add (pure, math)
    // float add_result = time_val + envelope_val;

    // // Node: Hsv (pure, color)
    // CRGBF color = hsv_to_rgb(
    //     time_val,          // hue (0-1)
    //     params.saturation, // saturation (0-1)
    //     envelope_val       // value (0-1)
    // );

    // Node: Fill (pure, buffer)
    fill_buffer(temp_buf_0, {0.5f, 0.5f, 0.5f}, PATTERN_NUM_LEDS);

    // Node: LowPass (stateful, filter)
    // Note: Filter state persists in PatternState across frames
    // float filtered = lowpass_update(state.lowpass_states[0], envelope_val, 0.1f);

    // Node: BufferPersist (stateful, buffer)
    // Exponential decay: out = decay * prev + (1 - decay) * new
    for (int i = 0; i < PATTERN_NUM_LEDS; i++) {
        state.persist_buf[i] = 0.95f * state.persist_buf[i] + (1.0f - 0.95f) * temp_buf_0[i].r;
    }

    // Node: LedOutput (terminal, output)
    // Write final buffer to hardware with RGB clamping
    for (int i = 0; i < PATTERN_NUM_LEDS; i++) {
        CRGBF clamped = clamped_rgb(temp_buf_0[i]);
        out.leds[i][0] = (uint8_t)(clamped.r * 255);
        out.leds[i][1] = (uint8_t)(clamped.g * 255);
        out.leds[i][2] = (uint8_t)(clamped.b * 255);
    }

    // ========================================================================
    // CONSTRAINT VALIDATION (compile-time, but noted for understanding)
    // ========================================================================

    // ✓ No heap allocations (all arrays stack-allocated or pre-allocated)
    // ✓ Single get_audio_snapshot() call (captured in audio param)
    // ✓ Color clamping applied to output (via clamped_rgb)
    // ✓ Temporary buffers <16 KB (temp_buf_0 + temp_buf_1 = ~10 KB)
    // ✓ Persistent state <1 KB (state struct bounded)
    // ✓ Stateful node execution order preserved (dependencies respected)
}

}  // namespace pattern_example

// ============================================================================
// PATTERN REGISTRATION (Called by firmware)
// ============================================================================

/**
 * Pattern metadata and render function pointer
 * Registered with pattern registry for runtime selection
 */

extern "C" {
void pattern_example_init(PatternState& state) {
    // Initialize stateful nodes (optional; PatternState constructor handles it)
}

void pattern_example_cleanup(PatternState& state) {
    // Cleanup if needed (optional)
}

// PatternRenderFunc get_pattern_example() {
//     return pattern_example_render;
// }
}
