#!/usr/bin/env python3
"""
Generate precomputed lookup tables for tempo detection.

This script eliminates runtime cosf/sinf calls by precomputing Goertzel
coefficients for all 64 tempo bins during the build process.

Output: firmware/src/audio/tempo_lut.h
Usage: python3 tools/generate_tempo_luts.py > firmware/src/audio/tempo_lut.h

Expected savings: ~10,240 cycles at boot (160 cycles × 64 bins)
"""

import math
import sys

# Configuration (must match tempo.h)
NUM_TEMPI = 64
NOVELTY_LOG_HZ = 50.0
TEMPO_LOW = 32   # BPM (64 - 32 from tempo.h)
TEMPO_HIGH = 160  # BPM (192 - 32 from tempo.h)
REFERENCE_FPS = 100.0

def generate_tempo_lut():
    """Generate C header with precomputed tempo constants."""

    # Header
    print("// Auto-generated by tools/generate_tempo_luts.py")
    print("// DO NOT EDIT MANUALLY")
    print("//")
    print("// Precomputed Goertzel coefficients for tempo detection.")
    print("// Eliminates runtime trig function calls in init_tempo_goertzel_constants().")
    print()
    print("#ifndef TEMPO_LUT_H")
    print("#define TEMPO_LUT_H")
    print()
    print("#include <stdint.h>")
    print()
    print("// Tempo bin constants (cosine, sine, coeff, phase advance)")
    print("struct TempoConstants {")
    print("    float cosine;                        // cos(ω) for Goertzel")
    print("    float sine;                          // sin(ω) for Goertzel")
    print("    float coeff;                         // 2*cos(ω) (precomputed)")
    print("    float phase_radians_per_ref_frame;   // Phase advance per 100Hz ref frame")
    print("};")
    print()
    print(f"// {NUM_TEMPI} tempo bins spanning {TEMPO_LOW}-{TEMPO_HIGH} BPM")
    print(f"const TempoConstants TEMPO_LUT[{NUM_TEMPI}] = {{")

    # Generate entries
    for i in range(NUM_TEMPI):
        progress = i / NUM_TEMPI
        tempo_bpm = (TEMPO_HIGH - TEMPO_LOW) * progress + TEMPO_LOW
        tempo_hz = tempo_bpm / 60.0

        # Compute block size (matches tempo.cpp logic)
        # Note: This is a simplified version; actual code considers neighbor distances
        # For LUT generation, we use the target tempo directly
        block_size = int(NOVELTY_LOG_HZ / tempo_hz)
        if block_size > 1024:  # NOVELTY_HISTORY_LENGTH
            block_size = 1024

        # Goertzel frequency bin calculation
        k = round(block_size * tempo_hz / NOVELTY_LOG_HZ)
        w = (2.0 * math.pi * k) / block_size

        # Precompute trig functions
        cos_w = math.cos(w)
        sin_w = math.sin(w)
        coeff = 2.0 * cos_w

        # Phase advance per reference frame (100 FPS)
        phase_rads_per_ref = (2.0 * math.pi * tempo_hz) / REFERENCE_FPS

        # Output C initializer
        print(f"    {{ {cos_w:12.9f}f, {sin_w:12.9f}f, {coeff:12.9f}f, {phase_rads_per_ref:12.9f}f }},  // Bin {i:2d}: {tempo_bpm:6.2f} BPM ({tempo_hz:5.3f} Hz)")

    # Footer
    print("};")
    print()
    print("#endif  // TEMPO_LUT_H")

def main():
    """Main entry point."""
    try:
        generate_tempo_lut()
        return 0
    except Exception as e:
        print(f"Error generating tempo LUT: {e}", file=sys.stderr)
        return 1

if __name__ == "__main__":
    sys.exit(main())
